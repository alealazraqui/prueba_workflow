// Generated by CodiumAI

import { QueryBus } from '@cqrs';
import { UnauthorizedException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { Rol } from '@roles/entities/rol.entity';
import { User } from '@users/entities/user.entity';
import jwt from 'jsonwebtoken';
import { CreateTokenCommand } from './create-token.command.dto';
import { CreateTokenCommandHandler } from './create-token.handler';

describe('execute', () => {
  let createTokenCommandHandler: CreateTokenCommandHandler;
  let configService: ConfigService;
  let queryBus: QueryBus;

  beforeAll(async () => {
    const moduleRef: TestingModule = await Test.createTestingModule({
      providers: [
        CreateTokenCommandHandler,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn(),
          },
        },
        {
          provide: QueryBus,
          useValue: {
            execute: jest.fn(),
          },
        },
      ],
    }).compile();

    createTokenCommandHandler = moduleRef.get<CreateTokenCommandHandler>(CreateTokenCommandHandler);
    configService = moduleRef.get<ConfigService>(ConfigService);
    queryBus = moduleRef.get<QueryBus>(QueryBus);
  });

  afterAll(() => {
    jest.clearAllMocks();
  });

  // Returns a JWT token when valid email and expiresIn are provided
  it('should return a JWT token when valid email and expiresIn are provided', async () => {
    // Arrange
    const command = new CreateTokenCommand();
    command.email = 'test@example.com';
    command.expiresIn = '1h';
    const user = new User();
    user.email = 'test@example.com';
    user.id = 1;
    user.rol = new Rol();
    user.rol.id = 1;
    user.rol.description = 'admin';
    (queryBus.execute as jest.Mock).mockResolvedValue(user);
    (configService.get as jest.Mock).mockReturnValueOnce('mockedIssuer').mockReturnValueOnce('mockedSecret');
    const result = await createTokenCommandHandler.execute(command);
    expect(result).toBeDefined();
    expect(result).toEqual(expect.any(String));
    // Decodificar el JWT y verificar el payload
    const decodedPayload = jwt.decode(result);
    expect(decodedPayload).toBeDefined();
    expect(decodedPayload).toHaveProperty('user');
    // Verificar que la propiedad 'user' existe y contiene los valores esperados
    if (decodedPayload && typeof decodedPayload === 'object' && 'user' in decodedPayload) {
      expect(decodedPayload.user).toEqual(
        expect.objectContaining({
          email: 'test@example.com',
          id: 1,
          rolId: 1,
          rolDescription: 'admin',
        }),
      );
    } else {
      throw new Error('El payload decodificado no contiene un objeto "user"');
    }
  });

  // Throws an error when email is not provided
  it('should throw an error when user is not found', async () => {
    // Arrange
    const command = new CreateTokenCommand();
    command.expiresIn = '1h';
    (queryBus.execute as jest.Mock).mockResolvedValue(null);
    // Act and Assert
    await expect(createTokenCommandHandler.execute(command)).rejects.toThrow(UnauthorizedException);
  });
});
