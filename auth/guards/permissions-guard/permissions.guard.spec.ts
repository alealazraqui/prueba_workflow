// Generated by CodiumAI

import { ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { PermissionsRepository } from '@permissions/repositories/permissions.repository';
import { PermissionsGuard } from './permissions.guard';
import { RolesEnum } from '@roles/enums/roles-enum';

let reflectorMock: Partial<Reflector>;
let permissionsRepositoryMock: Partial<PermissionsRepository>;
let contextMock: Partial<ExecutionContext>;
let contextSuperUserMock: Partial<ExecutionContext>;
let permissionsGuard: PermissionsGuard;

describe('PermissionsGuard', () => {
  beforeEach(() => {
    reflectorMock = {
      getAllAndOverride: jest.fn().mockReturnValue(undefined),
    };
    permissionsRepositoryMock = {
      getPermissionByRole: jest.fn(),
    };
    contextMock = {
      getHandler: jest.fn(),
      getClass: jest.fn(),
      switchToHttp: jest.fn().mockReturnValue({
        getRequest: jest.fn().mockReturnValue({ user: { rolId: 1 } }),
      }),
    };
    contextSuperUserMock = {
      getHandler: jest.fn(),
      getClass: jest.fn(),
      switchToHttp: jest.fn().mockReturnValue({
        getRequest: jest.fn().mockReturnValue({ user: { rolId: RolesEnum.SUPER_USUARIO } }),
      }),
    };
    permissionsGuard = new PermissionsGuard(
      reflectorMock as Reflector,
      permissionsRepositoryMock as PermissionsRepository,
    );
  });

  afterAll(() => {
    jest.clearAllMocks();
  });
  // When the requiredActions is not defined, canActivate should return true without throwing any exception.
  it('should return true when requiredActions is not defined', async () => {
    // Arrange

    // Act
    const result = await permissionsGuard.canActivate(contextMock as ExecutionContext);

    // Assert
    expect(result).toBe(true);
  });

  // When the requiredActions is defined and the user has the required permissions, canActivate should return true without throwing any exception.
  it('should return true when requiredActions is defined and user has required permissions', async () => {
    // Arrange
    reflectorMock.getAllAndOverride = jest.fn().mockReturnValue(['permission1', 'permission2']);
    permissionsRepositoryMock.getPermissionByRole = jest.fn().mockResolvedValue(['permission1', 'permission2']);

    // Act
    const result = await permissionsGuard.canActivate(contextMock as ExecutionContext);
    // Assert
    expect(result).toBe(true);
  });

  // When the requiredActions is defined and the user does not have the required permissions, canActivate should throw an UnauthorizedException.
  it('should throw UnauthorizedException when user does not have required permissions', async () => {
    // Arrange
    reflectorMock.getAllAndOverride = jest.fn().mockReturnValue(['permission1', 'permission2']);
    permissionsRepositoryMock.getPermissionByRole = jest.fn().mockResolvedValue(['permission3', 'permission4']);

    // Act and Assert
    await expect(permissionsGuard.canActivate(contextMock as ExecutionContext)).rejects.toThrow(UnauthorizedException);
  });

  // When the requiredActions is defined and the user has the required permissions, canActivate should return true without throwing any exception.
  it('should return true when requiredActions is defined and user has one of the permissions', async () => {
    // Arrange
    reflectorMock.getAllAndOverride = jest.fn().mockReturnValue(['permission1', 'permission2']);
    permissionsRepositoryMock.getPermissionByRole = jest.fn().mockResolvedValue(['permission1', 'permission4']);

    // Act
    const result = await permissionsGuard.canActivate(contextMock as ExecutionContext);

    // Assert
    expect(result).toBe(true);
  });

  // When the requiredActions is defined and the user does not have the required permissions, canActivate should throw an UnauthorizedException.
  it('should throw UnauthorizedException when user has not rol ', async () => {
    reflectorMock.getAllAndOverride = jest.fn().mockReturnValue(['permission1', 'permission2']);
    permissionsRepositoryMock.getPermissionByRole = jest.fn().mockResolvedValue(['permission3', 'permission4']);
    contextMock.switchToHttp = jest.fn().mockReturnValue({
      getRequest: jest.fn().mockReturnValue({ user: { roles: [] } }),
    });

    // Act and Assert
    await expect(permissionsGuard.canActivate(contextMock as ExecutionContext)).rejects.toThrow(UnauthorizedException);
  });

  it('should throw UnauthorizedException when user has rol with empty permissions ', async () => {
    // Arrange
    reflectorMock.getAllAndOverride = jest.fn().mockReturnValue(['permission1', 'permission2']);
    permissionsRepositoryMock.getPermissionByRole = jest.fn().mockResolvedValue([]);

    // Act and Assert
    await expect(permissionsGuard.canActivate(contextMock as ExecutionContext)).rejects.toThrow(UnauthorizedException);
  });

  it('should return true for rol SUPER USUARIO', async () => {
    // Arrange
    reflectorMock.getAllAndOverride = jest.fn().mockReturnValue(['permission1', 'permission2']);
    permissionsRepositoryMock.getPermissionByRole = jest.fn().mockResolvedValue([]);
    // Act
    const result = await permissionsGuard.canActivate(contextSuperUserMock as ExecutionContext);

    // Assert
    expect(result).toBe(true);
  });
});
